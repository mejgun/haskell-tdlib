module TD.Data.LocalFile
  (LocalFile(..)) where

import qualified Data.Aeson as A
import qualified Data.Aeson.Types as AT
import qualified TD.Lib.Internal as I
import qualified Data.Text as T

data LocalFile
  = LocalFile -- ^ Represents a local file
    { path                     :: Maybe T.Text -- ^ Local path to the locally available file part; may be empty
    , can_be_downloaded        :: Maybe Bool   -- ^ True, if it is possible to download or generate the file
    , can_be_deleted           :: Maybe Bool   -- ^ True, if the file can be deleted
    , is_downloading_active    :: Maybe Bool   -- ^ True, if the file is currently being downloaded (or a local copy is being generated by some other means)
    , is_downloading_completed :: Maybe Bool   -- ^ True, if the local copy is fully available
    , download_offset          :: Maybe Int    -- ^ Download will be started from this offset. downloaded_prefix_size is calculated from this offset
    , downloaded_prefix_size   :: Maybe Int    -- ^ If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
    , downloaded_size          :: Maybe Int    -- ^ Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
    }
  deriving (Eq, Show)

instance I.ShortShow LocalFile where
  shortShow LocalFile
    { path                     = path_
    , can_be_downloaded        = can_be_downloaded_
    , can_be_deleted           = can_be_deleted_
    , is_downloading_active    = is_downloading_active_
    , is_downloading_completed = is_downloading_completed_
    , download_offset          = download_offset_
    , downloaded_prefix_size   = downloaded_prefix_size_
    , downloaded_size          = downloaded_size_
    }
      = "LocalFile"
        ++ I.cc
        [ "path"                     `I.p` path_
        , "can_be_downloaded"        `I.p` can_be_downloaded_
        , "can_be_deleted"           `I.p` can_be_deleted_
        , "is_downloading_active"    `I.p` is_downloading_active_
        , "is_downloading_completed" `I.p` is_downloading_completed_
        , "download_offset"          `I.p` download_offset_
        , "downloaded_prefix_size"   `I.p` downloaded_prefix_size_
        , "downloaded_size"          `I.p` downloaded_size_
        ]

instance AT.FromJSON LocalFile where
  parseJSON v@(AT.Object obj) = do
    t <- obj A..: "@type" :: AT.Parser String

    case t of
      "localFile" -> parseLocalFile v
      _           -> mempty
    
    where
      parseLocalFile :: A.Value -> AT.Parser LocalFile
      parseLocalFile = A.withObject "LocalFile" $ \o -> do
        path_                     <- o A..:?  "path"
        can_be_downloaded_        <- o A..:?  "can_be_downloaded"
        can_be_deleted_           <- o A..:?  "can_be_deleted"
        is_downloading_active_    <- o A..:?  "is_downloading_active"
        is_downloading_completed_ <- o A..:?  "is_downloading_completed"
        download_offset_          <- o A..:?  "download_offset"
        downloaded_prefix_size_   <- o A..:?  "downloaded_prefix_size"
        downloaded_size_          <- o A..:?  "downloaded_size"
        pure $ LocalFile
          { path                     = path_
          , can_be_downloaded        = can_be_downloaded_
          , can_be_deleted           = can_be_deleted_
          , is_downloading_active    = is_downloading_active_
          , is_downloading_completed = is_downloading_completed_
          , download_offset          = download_offset_
          , downloaded_prefix_size   = downloaded_prefix_size_
          , downloaded_size          = downloaded_size_
          }
  parseJSON _ = mempty

