{-# LANGUAGE OverloadedStrings #-}

-- |
module TD.Data.RemoteFile where

import qualified Data.Aeson as A
import qualified Data.Aeson.Types as T
import qualified Utils as U

-- |
data RemoteFile = -- | Represents a remote file
  RemoteFile
  { -- | Size of the remote available part of the file, in bytes; 0 if unknown
    uploaded_size :: Maybe Int,
    -- | True, if a remote copy is fully available
    is_uploading_completed :: Maybe Bool,
    -- | True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
    is_uploading_active :: Maybe Bool,
    -- | Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
    unique_id :: Maybe String,
    -- | Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers.
    -- If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known.
    -- If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string.
    -- Application must generate the file by downloading it to the specified location
    _id :: Maybe String
  }
  deriving (Eq)

instance Show RemoteFile where
  show
    RemoteFile
      { uploaded_size = uploaded_size_,
        is_uploading_completed = is_uploading_completed_,
        is_uploading_active = is_uploading_active_,
        unique_id = unique_id_,
        _id = _id_
      } =
      "RemoteFile"
        ++ U.cc
          [ U.p "uploaded_size" uploaded_size_,
            U.p "is_uploading_completed" is_uploading_completed_,
            U.p "is_uploading_active" is_uploading_active_,
            U.p "unique_id" unique_id_,
            U.p "_id" _id_
          ]

instance T.FromJSON RemoteFile where
  parseJSON v@(T.Object obj) = do
    t <- obj A..: "@type" :: T.Parser String

    case t of
      "remoteFile" -> parseRemoteFile v
      _ -> mempty
    where
      parseRemoteFile :: A.Value -> T.Parser RemoteFile
      parseRemoteFile = A.withObject "RemoteFile" $ \o -> do
        uploaded_size_ <- o A..:? "uploaded_size"
        is_uploading_completed_ <- o A..:? "is_uploading_completed"
        is_uploading_active_ <- o A..:? "is_uploading_active"
        unique_id_ <- o A..:? "unique_id"
        _id_ <- o A..:? "id"
        return $ RemoteFile {uploaded_size = uploaded_size_, is_uploading_completed = is_uploading_completed_, is_uploading_active = is_uploading_active_, unique_id = unique_id_, _id = _id_}
  parseJSON _ = mempty

instance T.ToJSON RemoteFile where
  toJSON
    RemoteFile
      { uploaded_size = uploaded_size_,
        is_uploading_completed = is_uploading_completed_,
        is_uploading_active = is_uploading_active_,
        unique_id = unique_id_,
        _id = _id_
      } =
      A.object
        [ "@type" A..= T.String "remoteFile",
          "uploaded_size" A..= uploaded_size_,
          "is_uploading_completed" A..= is_uploading_completed_,
          "is_uploading_active" A..= is_uploading_active_,
          "unique_id" A..= unique_id_,
          "id" A..= _id_
        ]
