module TD.Data.RemoteFile
  (RemoteFile(..)) where

import qualified Data.Aeson as A
import qualified Data.Aeson.Types as AT
import qualified TD.Lib.Internal as I
import qualified Data.Text as T

data RemoteFile
  = RemoteFile -- ^ Represents a remote file
    { _id                    :: Maybe T.Text -- ^ Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. If the identifier starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. If downloadFile/addFileToDownloads is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
    , unique_id              :: Maybe T.Text -- ^ Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
    , is_uploading_active    :: Maybe Bool   -- ^ True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
    , is_uploading_completed :: Maybe Bool   -- ^ True, if a remote copy is fully available
    , uploaded_size          :: Maybe Int    -- ^ Size of the remote available part of the file, in bytes; 0 if unknown
    }
  deriving (Eq, Show)

instance I.ShortShow RemoteFile where
  shortShow RemoteFile
    { _id                    = _id_
    , unique_id              = unique_id_
    , is_uploading_active    = is_uploading_active_
    , is_uploading_completed = is_uploading_completed_
    , uploaded_size          = uploaded_size_
    }
      = "RemoteFile"
        ++ I.cc
        [ "_id"                    `I.p` _id_
        , "unique_id"              `I.p` unique_id_
        , "is_uploading_active"    `I.p` is_uploading_active_
        , "is_uploading_completed" `I.p` is_uploading_completed_
        , "uploaded_size"          `I.p` uploaded_size_
        ]

instance AT.FromJSON RemoteFile where
  parseJSON v@(AT.Object obj) = do
    t <- obj A..: "@type" :: AT.Parser String

    case t of
      "remoteFile" -> parseRemoteFile v
      _            -> mempty
    
    where
      parseRemoteFile :: A.Value -> AT.Parser RemoteFile
      parseRemoteFile = A.withObject "RemoteFile" $ \o -> do
        _id_                    <- o A..:?  "id"
        unique_id_              <- o A..:?  "unique_id"
        is_uploading_active_    <- o A..:?  "is_uploading_active"
        is_uploading_completed_ <- o A..:?  "is_uploading_completed"
        uploaded_size_          <- o A..:?  "uploaded_size"
        pure $ RemoteFile
          { _id                    = _id_
          , unique_id              = unique_id_
          , is_uploading_active    = is_uploading_active_
          , is_uploading_completed = is_uploading_completed_
          , uploaded_size          = uploaded_size_
          }
  parseJSON _ = mempty

